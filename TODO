--*- Mode: Indented-text; -*-

Scheme 48: list of bugs and things to do.
Last update by JAR on 2 February 1994.

Run-time system bugs:
    Compiler needs to treat calls with more than 63 arguments specially.
    MAX and MIN don't do inexact contagion.
    Shadowing is broken for macro-referenced variables:
        (define (foo x) `(a ,x))
	(define cons list)
	(foo 1) => (a (1 ()))
    The WITH-**PUT-FILE and CALL-WITH-**PUT-PORT procedures probably
      close ports sooner than the Scheme reports think they ought to.
      (They just do the obvious DYNAMIC-WIND.)
    If (find-all-symbols) fails due to lack of space, it should GC and
      retry (I think) (bug reported by Basile Starynkevitch, 7-21-93)

Programming environment:
    Error checking for macro & special form syntax.
    Fuller on-line documentation.
    Error recovery.  Can do better than ,proceed.  LOAD should set up
      restart continuations.
    Types in scheme-interface (and elsewhere) aren't as tight as they
      could be.
    LET continuation "pessimization" to retain the environment longer.
    Have the disassembler display local variable names.
    This ought to be recoverable, but isn't always:
	> (let loop ((x '())) (loop (cons 3 x)))
	not enough room in heap for stack
    Put the inspector at its own command level, so that ^D after
      errors puts you back in the inspector.
    The get-cont-from-heap instruction should have an exception
      discloser that indicates the actual error (returning a
      non-fixnum from application top level).
    Separate compilation (compile a module, writing object code to a
      file).  (Rudiments in misc/separate.scm)
    Semicolon comments don't quite work after commands (extra newline
      required).
    Command (and procedure) to change current directory.

Performance:
    Put initial pure objects in read-only memory somehow (for faster
      startup and fork() calls).
    More compact representation for debugging data?
    Leaf procedure compilation (RK's rts/no-leaf-env.scm): if no
      continuations or lambdas, skip the make-env and access locals
      using stack-ref.  Expected to gain about 6% in speed.
    Optimize loops somehow (maybe using call-template opcode and/or
      opportunistic compilation).
    The CAML light implementation has good documentation and patches
      for optimizing the interpreter's switch (*pc++); perhaps we
      could lift some of it.  (Range check isn't necessary.)
    Floating point support in VM.
    Bignum support in VM: use MIT Scheme bignums or GNU Multiple
      Precision Arithmetic Library (Torbjorn Granlund <tege@sics.se>).
    Faster bignum printer (e.g. the one Richard wrote - but it would be
      nice if it were an option tied to bignums, not built in to the
      initial image).
    Ratnum multiplication and division might be made more efficient by
      taking cross-GCD's.
    Native code compiler...

Big Scheme features:
    ,more-threads command doesn't get defined (new bug in 0.26).
    Add Olin's "cig" (C interface generator).
    How about deleting entries from tables?
    Non-blocking I/O for threads.  I think access to Unix select() might
      be sufficient (with pause() and sleep() as degenerate cases).
      Look at concurrent ML source code, which gets this right.
    RPC.
    Add call/gcc (invokes the Gnu C compiler).
    It would be nice if WITH-MULTITASKING returned whatever the thunk
      returned.
    ,exit following ,start-threads causes a core dump.

Module system bugs:
    ,untrace should undefine as well if the variable wasn't bound
      before.
    Compound signatures don't get updated when a component signature
      changes.  They contain a list of signatures with no reinitialization
      thunk a la structures and packages.

Module system features:
    Check for name conflicts between opened structures.
    Implement interface subtraction as a way of dealing with such
      conflicts: (WITHOUT (<name> ...) <interface>)
    Check for cycles in structure inheritance.
    An ,access command, similar to ,open.
    Deal with package system state better (for linker).  Maybe each
      package should point to a data structure containing
      *location-uid*, location-name-table, *package-uid*,
      package-name-table, and perhaps the compiler-state as well (see
      segment.scm).

VM:
    Fix alleged non-ANSI C gotos, the ones that go in and out of block
      expecting locals to be preserved.
    The ATAN byte code should take two operands, not one.
    Maximum vector length checking is unjustly conservative, with the
      result that you can't make vectors (and stored objects
      generally) larger than 1/4 the size of one semispace.
    Merge in Olin's changes and extensions (command line processing,
      the #! syntax for scripts, external function call, etc.).
    Interrupt while writing out image causes an exit.  [Fixed?]
    A jump-back instruction.  Might be easier to use than call-template.
    Scrutinize all VM fatal errors to see if any can be recovered
      from.  E.g. "out of ports" shouldn't cause a VM halt, it should
      just cause open-port to return #f or an error code.
    Get VM debugging environment (load-debug in vm/load.scm) working.
    Get VM interp.scm-without-gc.scm working again.
    Null terminated strings [fixed in RK's version].

Documentation:
    user-guide.txt should point to the existing lsc.ps?
    (optimize auto-integrate) and ,load-package analysis.
    How to use the static linker.
    How scheme48.image gets built.
    Techniques for debugging the runtime system (debug/for-debugging.scm).
    Threads, fluids, records, tables.
    File name translation and the ,translate command.
    Retrieve the external function call-back code that I wrote for
      Mark Sheldon, and put it in the doc/ directory.

Cleanup:
  VM:
    Fix unix.c and the other .c files to be Posix compliant, to the
      extent possible.  E.g. use sigaction() instead of signal() and
      time() instead of ftime().  Default case for every compile-time
      conditionalization should assume Posix.
    Revert to the old exception system: vector of handlers (not just a
      single procedure), and each handler gets an exception code.
    Rename "unassigned" to "uninitialized"?  Or phase it out entirely.
  Run-time / features / development environment:
    Figure out how to merge the two type systems (META-METHODS and
      META-TYPES).  The generic function system could make use of the
      SUBTYPE? and INTERSECT? predicates.
    Correct floating point, esp. reading and printing.
    Parameterize over file name syntax somehow.  Currently
      big/filename.scm assumes Unix (cf. DIRECTORY-COMPONENT-SEPARATOR,
      FILE-NAME-PREFERRED-CASE).  Perhaps there should be VM support for
      this.
    Make sure that the disassembler and assembler are inverses of one
      another.
    Disassembler should generate S-expression first, and then print
      it independently.
    Combine condition, signals, and handle into a single structure?
    Figure out a better way to implement ##.
  Compiler / linker / module system:
    Flush link/data.scm.  Linker should instead open the VM module
      that includes vm/data.scm.
    Flush (optimize ...) clause in DEFINE-STRUCTURE in favor of
      optimizer argument to SCAN-STRUCTURES.
    Vector patterns and templates ought to be supported in
      SYNTAX-RULES.
    The DEFINE-INTERFACE forms should contain types for every exported
      variable; the code in cprim.scm (and recon.scm?) shouldn't have
      to worry about setting up types.
    Add ENVIRONMENT-DEFINED? ?
    Make USUAL-TRANSFORM return a transform?
    Add enough to the node signature to make it usable on its own?
  Etc:
    Start using a source control system (like rcs).
    We ought to have a test system / validation suite.



Date: Mon, 14 Jun 93 18:33:30 HKT
From: shivers@csd.hku.hk
To: kelsey@flora.ccs.neu.edu
Cc: jar@cs.cornell.edu
Subject: Scheme 48

...
All true.  My major motivation was portability. I also found the module system
to be a big win. Other things that influenced me were (1) elegance and
modularity -- I felt I could comprehend and mung the system as needed (2)
reasonable efficiency and small size and (3) real, full R4RS+ support (most
small systems do it partly).

Actually, I wouldn't say the programming environment is particularly
exceptional, unless you count the module system.

A small thing lacking in other Schemes that really reduced my debug times: the
loader would complain about undefined free var refs in my code. This
frequently picked out variable spelling errors, inconsistent name linkages,
and forgotten procedure defs. Not a big thing, but really effective.

Another win was simply having the implementors around for detailed
explanations and support.

Problems I had with S48: 
- Inability to mess with the VM, as it is written in a language that can
  be compiled by only 1 person in the world.

- The foreign-function support was quite limited, and the foreign-data support
  was basically non-existent. Exporting gc'd data to C, gc'ing data allocated
  in C, hooks into the GC, importing C data into Scheme -- no support.  Elk
  handles this better, as that is critical to the type of applications at
  which elk is targeted.

  I fixed some of this myself -- helped by your general, portable low-level ff
  interface, which was well-designed in terms of those goals -- but I couldn't
  do much about foreign-data support.

- No support currently for linking static heap data into a text-pages
  area to reduce gc copying and shrink the dynamic heap.

- The module system was frequently frustrating. The non-uniform , command 
  language, bugs, the restrictions of living with a module system,
  being blocked from accessing primitives whose bindings had been
  gc'd away at link time, and awkwardnesses in the user interface really
  slowed me down.

  The module system was also a great help; these are simply the problems
  of life with an experimental system, as opposed to a polished final
  product.

[But] all in all, S48 was the best choice I could have made.  
