<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- HTML file produced from file: manual.tex --
 -- using Hyperlatex v 2.3.1 (c) Otfried Cheong--
 -- on Emacs 21.4 (patch 15) "Security Through Obscurity" XEmacs Lucid, Fri Dec  3 20:36:17 2004 -->
<HEAD>
<TITLE>Scheme 48 Manual -- General utilities</TITLE>

</HEAD><BODY BGCOLOR="#ffffff">
<EM>Scheme 48 Manual</EM> | <A HREF="s48manual.html#top_node">Contents</A> | In Chapter: <A HREF="s48manual_35.html">Libraries</A><BR>Previous: <A HREF="s48manual_35.html">Libraries</A> | Next: <A HREF="s48manual_37.html">Pretty-printing</A>
<H2>General utilities</H2>

<P>These are in the <CODE>big-util</CODE> structure.
<P><UL><LI><CODE>(atom?<I>&nbsp;value</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="1">&nbsp;</A>
</UL>
<CODE>(atom? <I>x</I>)</CODE> is the same as <CODE>(not (pair? <I>x</I>))</CODE>.
<P><UL><LI><CODE>(null-list?<I>&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="2">&nbsp;</A>
</UL>
Returns true for the empty list, false for a pair, and signals an
error otherwise.
<P><UL><LI><CODE>(neq?<I>&nbsp;value&nbsp;value</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="3">&nbsp;</A>
</UL>
<CODE>(neq? <I>x</I> <I>y</I>)</CODE> is the same as <CODE>(not (eq? <I>x</I>
<I>y</I>))</CODE>.
<P><UL><LI><CODE>(n=<I>&nbsp;number&nbsp;number</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="4">&nbsp;</A>
</UL>
<CODE>(n= <I>x</I> <I>y</I>)</CODE> is the same as <CODE>(not (= <I>x</I>
  <I>y</I>))</CODE>.
<P><UL><LI><CODE>(identity<I>&nbsp;value</I>)&nbsp;-&gt;&nbsp;<I>value</I></CODE><A NAME="5">&nbsp;</A>
<LI><CODE>(no-op<I>&nbsp;value</I>)&nbsp;-&gt;&nbsp;<I>value</I></CODE><A NAME="6">&nbsp;</A>
</UL>
These both just return their argument.  <CODE>No-op</CODE> is guaranteed not to
be compiled in-line, <CODE>identity</CODE> may be.
<P><UL><LI><CODE>(memq?<I>&nbsp;value&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="7">&nbsp;</A>
</UL>
Returns true if <I>value</I> is in <I>list</I>, false otherwise.
<P><UL><LI><CODE>(any?<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="8">&nbsp;</A>
</UL>
Returns true if <I>predicate</I> is true for any element of <I>list</I>.
<P><UL><LI><CODE>(every?<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="9">&nbsp;</A>
</UL>
  Returns true if <I>predicate</I> is true for every element of <I>list</I>.
<P><UL><LI><CODE>(any<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>value</I></CODE><A NAME="10">&nbsp;</A>
<LI><CODE>(first<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>value</I></CODE><A NAME="11">&nbsp;</A>
</UL>
<CODE>Any</CODE> returns some element of <I>list</I> for which <I>predicate</I> is true, or
false if there are none.  <CODE>First</CODE> does the same except that it returns
the first element for which <I>predicate</I> is true.
<P><UL><LI><CODE>(filter<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="12">&nbsp;</A>
<LI><CODE>(filter!<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="13">&nbsp;</A>
</UL>
Returns a list containing all of the elements of <I>list</I> for which
<I>predicate</I> is true.  The order of the elements is preserved.
<CODE>Filter!</CODE> may reuse the storage of <I>list</I>.
<P><UL><LI><CODE>(filter-map<I>&nbsp;procedure&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="14">&nbsp;</A>
</UL>
The same as <CODE>filter</CODE> except the returned list contains the results of
applying <I>procedure</I> instead of elements of <I>list</I>.  <CODE>(filter-map <I>p</I>
<I>l</I>)</CODE> is the same as <CODE>(filter identity (map <I>p</I> <I>l</I>))</CODE>.
<P><UL><LI><CODE>(partition-list<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list&nbsp;list</I></CODE><A NAME="15">&nbsp;</A>
<LI><CODE>(partition-list!<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list&nbsp;list</I></CODE><A NAME="16">&nbsp;</A>
</UL>
The first return value contains those elements <I>list</I> for which
<I>predicate</I> is true, the second contains the remaining elements.
The order of the elements is preserved.  <CODE>Partition-list!</CODE> may
reuse the storage of the <I>list</I>.
<P><UL><LI><CODE>(remove-duplicates<I>&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="17">&nbsp;</A>
</UL>
Returns its argument with all duplicate elements removed.  The first
instance of each element is preserved.
<P><UL><LI><CODE>(delq<I>&nbsp;value&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="18">&nbsp;</A>
<LI><CODE>(delq!<I>&nbsp;value&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="19">&nbsp;</A>
<LI><CODE>(delete<I>&nbsp;predicate&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="20">&nbsp;</A>
</UL>
All three of these return <I>list</I> with some elements removed.
<CODE>Delq</CODE> removes all elements <CODE>eq?</CODE> to <I>value</I>.  <CODE>Delq!</CODE>
does the same and may modify the list argument.  <CODE>Delete</CODE> removes
all elements for which <I>predicate</I> is true.  Both <CODE>delq</CODE> and
<CODE>delete</CODE> may reuse some of the storage in the list argument, but
won't modify it.
<P><UL><LI><CODE>(reverse!<I>&nbsp;list</I>)&nbsp;-&gt;&nbsp;<I>list</I></CODE><A NAME="21">&nbsp;</A>
</UL>
Destructively reverses <I>list</I>.
<P><UL><LI><CODE>(concatenate-symbol<I>&nbsp;value&nbsp;...</I>)&nbsp;-&gt;&nbsp;<I>symbol</I></CODE><A NAME="22">&nbsp;</A>
</UL>
Returns the symbol whose name is produced by concatenating the
<CODE>display</CODE>ed
representations of <I>value</I>&nbsp;....
<P><BLOCKQUOTE><PRE>
(concatenate-symbol 'abc "-" 4) <I>==&gt;</I> 'abc-4
</PRE></BLOCKQUOTE>
<P><P>
  
Previous: <A HREF="s48manual_35.html">Libraries</A> | Next: <A HREF="s48manual_37.html">Pretty-printing</A></BODY></HTML>
